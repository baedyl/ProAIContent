/**
 * SERP Analysis Utilities
 * Analyze Google search results for competitive insights
 */

import { getJson } from 'serpapi'
import cheerio from 'cheerio'

export interface SerpResult {
  position: number
  title: string
  link: string
  snippet: string
  date?: string
}

export interface RelatedQuestion {
  question: string
  snippet: string
  title: string
  link: string
}

export interface SerpAnalysis {
  keyword: string
  totalResults: number
  topResults: SerpResult[]
  relatedQuestions: RelatedQuestion[]
  peopleAlsoAsk: string[]
  relatedSearches: string[]
  timestamp: string
}

/**
 * Analyze SERP for a given keyword
 */
interface SerpApiResult {
  title?: string
  link?: string
  snippet?: string
  date?: string
}

interface SerpApiRelatedQuestion {
  question?: string
  snippet?: string
  title?: string
  link?: string
}

export async function analyzeSERP(
  keyword: string,
  location: string = 'us'
): Promise<SerpAnalysis> {
  try {
    const apiKey = process.env.SERPAPI_KEY

    if (!apiKey) {
      throw new Error('SERPAPI_KEY not configured')
    }

    // Map location codes
    const locationMap: Record<string, { hl: string, gl: string }> = {
      'us': { hl: 'en', gl: 'us' },
      'uk': { hl: 'en', gl: 'uk' },
      'fr': { hl: 'fr', gl: 'fr' },
      'de': { hl: 'de', gl: 'de' },
      'br': { hl: 'pt', gl: 'br' }
    }

    const loc = locationMap[location] || locationMap['us']

    // Query SerpAPI
    const response = await getJson({
      engine: 'google',
      q: keyword,
      api_key: apiKey,
      hl: loc.hl,
      gl: loc.gl,
      num: 25
    })

    // Extract top organic results
    const topResults: SerpResult[] = (response.organic_results || [])
      .slice(0, 10)
      .map((result: SerpApiResult, index: number) => ({
        position: index + 1,
        title: result.title || '',
        link: result.link || '',
        snippet: result.snippet || '',
        date: result.date
      }))

    // Extract related questions (People Also Ask)
    const relatedQuestions: RelatedQuestion[] = (response.related_questions || [])
      .map((q: SerpApiRelatedQuestion) => ({
        question: q.question || '',
        snippet: q.snippet || '',
        title: q.title || '',
        link: q.link || ''
      }))

    const peopleAlsoAsk = relatedQuestions.map(q => q.question)

    // Extract related searches
    const relatedSearches = (response.related_searches || [])
      .map((s: { query?: string }) => s.query || '')
      .filter(Boolean)

    return {
      keyword,
      totalResults: response.search_information?.total_results || 0,
      topResults,
      relatedQuestions,
      peopleAlsoAsk,
      relatedSearches,
      timestamp: new Date().toISOString()
    }
  } catch (error: unknown) {
    console.error('SERP analysis error:', error)
    
    // Return minimal data if SERP analysis fails
    return {
      keyword,
      totalResults: 0,
      topResults: [],
      relatedQuestions: [],
      peopleAlsoAsk: [],
      relatedSearches: [],
      timestamp: new Date().toISOString()
    }
  }
}

/**
 * Extract competitor headers from top-ranking pages
 */
export async function extractCompetitorHeaders(
  urls: string[],
  maxUrls: number = 5
): Promise<string[]> {
  const headers: string[] = []
  
  // Only process first maxUrls
  const targetUrls = urls.slice(0, maxUrls)

  for (const url of targetUrls) {
    try {
      const response = await fetch(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        },
        signal: AbortSignal.timeout(5000) // 5 second timeout
      })

      if (!response.ok) continue

      const html = await response.text()
      
      // Use cheerio to parse HTML
      const $ = cheerio.load(html)

      // Try to find article content
      const article = $('article').length > 0 ? $('article') : $('main')

      // Extract h2 and h3 headers
      article.find('h2, h3').each((_, element) => {
        const text = $(element).text().trim()
        const tag = element.tagName.toLowerCase()
        
        if (text && text.length > 10 && text.length < 200) {
          headers.push(`${tag}:${text}`)
        }
      })

      // Break if we have enough headers
      if (headers.length >= 10) break

    } catch (error) {
      console.error(`[Headers Agent] Error fetching ${url}:`, error)
      continue
    }
  }

  return headers
}

/**
 * Generate FAQ from People Also Ask questions
 */
export async function generateFAQFromPAA(
  questions: string[]
): Promise<Array<{ question: string, answer: string }>> {
  // This will be called from the API route with OpenAI
  // Just return the questions here, answers will be generated by AI
  return questions.slice(0, 7).map(q => ({
    question: q,
    answer: '' // Will be filled by AI
  }))
}

/**
 * Search for YouTube videos related to keyword
 */
export async function searchYouTubeVideo(keyword: string): Promise<string | null> {
  try {
    // Build YouTube search URL
    const searchUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(keyword)}`
    
    const response = await fetch(searchUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      },
      signal: AbortSignal.timeout(5000)
    })

    if (!response.ok) return null

    const html = await response.text()

    // Extract video ID from response
    const videoIdMatch = html.match(/"videoId":"([^"]+)"/)
    
    if (videoIdMatch && videoIdMatch[1]) {
      const videoId = videoIdMatch[1]
      
      // Return embed iframe
      return `<iframe width="100%" height="450" src="https://www.youtube.com/embed/${videoId}?controls=1&autoplay=0&mute=1&modestbranding=1&rel=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>`
    }

    return null
  } catch (error) {
    console.error('YouTube search error:', error)
    return null
  }
}

/**
 * Build enhanced prompt with SERP insights
 */
export function buildSerpEnhancedPrompt(
  basePrompt: string,
  serpAnalysis: SerpAnalysis,
  competitorHeaders?: string[]
): string {
  let enhancedPrompt = basePrompt

  // Add competitor insights
  if (competitorHeaders && competitorHeaders.length > 0) {
    enhancedPrompt += `\n\nCOMPETITOR CONTENT STRUCTURE (for inspiration, rewrite uniquely):
${competitorHeaders.slice(0, 15).join('\n')}

IMPORTANT: Use these as inspiration for structure but rewrite everything in your own unique way. Do not copy.`
  }

  // Add related searches for semantic relevance
  if (serpAnalysis.relatedSearches.length > 0) {
    enhancedPrompt += `\n\nRELATED TOPICS TO COVER (for semantic SEO):
${serpAnalysis.relatedSearches.slice(0, 8).join(', ')}

Naturally incorporate these related concepts to improve topical authority.`
  }

  return enhancedPrompt
}

